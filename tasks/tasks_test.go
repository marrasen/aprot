package tasks

import (
	"reflect"
	"strings"
	"testing"

	"github.com/marrasen/aprot"
)

func TestAppendTaskConvenienceCode_SingleFileVanilla(t *testing.T) {
	results := map[string]string{
		"client.ts": "// base client\n",
	}
	appendTaskConvenienceCode(results, aprot.OutputVanilla, nil)

	code := results["client.ts"]
	appended := strings.TrimPrefix(code, "// base client\n")

	if _, ok := results["tasks.ts"]; ok {
		t.Error("should not create tasks.ts in single-file mode")
	}
	if !strings.Contains(appended, "export function cancelSharedTask") {
		t.Error("missing cancelSharedTask")
	}
	if strings.Contains(appended, "useSharedTasks") {
		t.Error("vanilla mode should not have React hooks")
	}
	if strings.Contains(appended, "import ") {
		t.Error("single-file mode should not have imports")
	}
}

func TestAppendTaskConvenienceCode_SingleFileReact(t *testing.T) {
	results := map[string]string{
		"client.ts": "// base client\n",
	}
	appendTaskConvenienceCode(results, aprot.OutputReact, nil)

	code := results["client.ts"]
	appended := strings.TrimPrefix(code, "// base client\n")

	if !strings.Contains(appended, "export function cancelSharedTask") {
		t.Error("missing cancelSharedTask")
	}
	if !strings.Contains(appended, "export function useSharedTasks") {
		t.Error("missing useSharedTasks hook")
	}
	if !strings.Contains(appended, "export function useSharedTask") {
		t.Error("missing useSharedTask hook")
	}
	if !strings.Contains(appended, "export function useMyTasks") {
		t.Error("missing useMyTasks hook")
	}
	if !strings.Contains(appended, "export function useTaskOutput") {
		t.Error("missing useTaskOutput hook")
	}
	if !strings.Contains(appended, "useCallback(() => setLines([])") {
		t.Error("missing useCallback in useTaskOutput")
	}
	if strings.Contains(appended, "import ") {
		t.Error("single-file mode should not have imports")
	}
}

func TestAppendTaskConvenienceCode_MultiFileVanilla(t *testing.T) {
	results := map[string]string{
		"client.ts":              "// base\n",
		"tasks-handler.ts": "// handler\n",
	}
	appendTaskConvenienceCode(results, aprot.OutputVanilla, nil)

	tasksCode, ok := results["tasks.ts"]
	if !ok {
		t.Fatal("tasks.ts should be created in multi-file mode")
	}
	if !strings.Contains(tasksCode, "// Code generated by aprot. DO NOT EDIT.") {
		t.Error("missing generated header")
	}
	if !strings.Contains(tasksCode, "import type { ApiClient, RequestOptions, TaskNode } from './client'") {
		t.Error("missing client imports")
	}
	if !strings.Contains(tasksCode, "import type { SharedTaskState, TaskStateEvent, TaskUpdateEvent } from './tasks-handler'") {
		t.Error("missing handler type imports")
	}
	if !strings.Contains(tasksCode, "export interface TaskRequestOptions") {
		t.Error("missing TaskRequestOptions")
	}
	if !strings.Contains(tasksCode, "export function taskOptions") {
		t.Error("missing taskOptions")
	}
	if !strings.Contains(tasksCode, "export function cancelSharedTask") {
		t.Error("missing cancelSharedTask")
	}
	if strings.Contains(tasksCode, "useSharedTasks") {
		t.Error("vanilla mode should not have React hooks")
	}
	// client.ts should not be modified
	if results["client.ts"] != "// base\n" {
		t.Error("client.ts should not be modified in multi-file mode")
	}
}

func TestAppendTaskConvenienceCode_MultiFileReact(t *testing.T) {
	results := map[string]string{
		"client.ts":              "// base\n",
		"tasks-handler.ts": "// handler\n",
	}
	appendTaskConvenienceCode(results, aprot.OutputReact, nil)

	tasksCode, ok := results["tasks.ts"]
	if !ok {
		t.Fatal("tasks.ts should be created in multi-file mode")
	}
	if !strings.Contains(tasksCode, "import { useState, useEffect, useCallback } from 'react'") {
		t.Error("missing React imports")
	}
	if !strings.Contains(tasksCode, "import type { ApiClient, RequestOptions, TaskNode } from './client'") {
		t.Error("missing client type imports")
	}
	if !strings.Contains(tasksCode, "import { useApiClient } from './client'") {
		t.Error("missing useApiClient import")
	}
	if !strings.Contains(tasksCode, "export interface TaskRequestOptions") {
		t.Error("missing TaskRequestOptions")
	}
	if !strings.Contains(tasksCode, "export function taskOptions") {
		t.Error("missing taskOptions")
	}
	if !strings.Contains(tasksCode, "export function cancelSharedTask") {
		t.Error("missing cancelSharedTask")
	}
	if !strings.Contains(tasksCode, "export function useSharedTasks") {
		t.Error("missing useSharedTasks")
	}
	if !strings.Contains(tasksCode, "export function useTaskOutput") {
		t.Error("missing useTaskOutput")
	}
}

type testMeta struct {
	UserName string `json:"userName,omitempty"`
	Error    string `json:"error,omitempty"`
}

func TestAppendTaskConvenienceCode_WithMeta(t *testing.T) {
	results := map[string]string{
		"client.ts": "// base\n",
	}

	metaType := reflect.TypeFor[testMeta]()
	appendTaskConvenienceCode(results, aprot.OutputVanilla, metaType)

	code := results["client.ts"]

	if !strings.Contains(code, "export interface testMeta") {
		t.Error("missing meta interface")
	}
	if !strings.Contains(code, "userName?: string") {
		t.Error("missing userName field")
	}
	if !strings.Contains(code, "error?: string") {
		t.Error("missing error field")
	}
}

type nestedChild struct {
	Value string `json:"value"`
}

type testMetaWithNested struct {
	Child nestedChild `json:"child"`
}

func TestAppendTaskConvenienceCode_WithNestedMeta(t *testing.T) {
	results := map[string]string{
		"client.ts": "// base\n",
	}

	metaType := reflect.TypeFor[testMetaWithNested]()
	appendTaskConvenienceCode(results, aprot.OutputVanilla, metaType)

	code := results["client.ts"]

	// Nested struct should appear before the parent
	if !strings.Contains(code, "export interface nestedChild") {
		t.Error("missing nested interface")
	}
	if !strings.Contains(code, "export interface testMetaWithNested") {
		t.Error("missing parent interface")
	}

	// Nested should come first
	nestedIdx := strings.Index(code, "export interface nestedChild")
	parentIdx := strings.Index(code, "export interface testMetaWithNested")
	if nestedIdx > parentIdx {
		t.Error("nested interface should appear before parent")
	}
}
