package tasks

import (
	"context"
	"fmt"
	"reflect"
	"strings"
	"time"

	"github.com/marrasen/aprot"
)

// taskCancelHandler is the handler struct for task cancellation.
type taskCancelHandler struct{}

func (h *taskCancelHandler) CancelTask(ctx context.Context, req *aprot.CancelTaskRequest) error {
	return aprot.CancelSharedTask(ctx, req.TaskID)
}

// Enable registers the shared task system with the registry.
func Enable(r *aprot.Registry) {
	r.SetTasksEnabled(true)
	r.RegisterEnum(aprot.TaskNodeStatusValues())
	handler := &taskCancelHandler{}
	r.Register(handler)
	r.RegisterPushEventFor(handler, aprot.TaskStateEvent{})
	r.RegisterPushEventFor(handler, aprot.TaskUpdateEvent{})
	r.OnGenerate(func(results map[string]string, mode aprot.OutputMode) {
		appendTaskConvenienceCode(results, mode, nil)
	})
}

// EnableWithMeta registers the shared task system with typed metadata.
func EnableWithMeta[M any](r *aprot.Registry) {
	metaType := reflect.TypeFor[M]()
	r.SetTaskMetaType(metaType)
	r.SetTasksEnabled(true)
	r.RegisterEnum(aprot.TaskNodeStatusValues())
	handler := &taskCancelHandler{}
	r.Register(handler)
	r.RegisterPushEventFor(handler, aprot.TaskStateEvent{})
	r.RegisterPushEventFor(handler, aprot.TaskUpdateEvent{})
	r.OnGenerate(func(results map[string]string, mode aprot.OutputMode) {
		appendTaskConvenienceCode(results, mode, metaType)
	})
}

// appendTaskConvenienceCode generates convenience TypeScript code for the task system.
// For multi-file mode it creates a tasks.ts file; for single-file mode it appends to client.ts.
func appendTaskConvenienceCode(results map[string]string, mode aprot.OutputMode, metaType reflect.Type) {
	// Determine if this is multi-file or single-file mode.
	// Multi-file: results has handler-specific files (e.g., "task-cancel-handler.ts")
	// Single-file: results only has "client.ts"
	_, hasHandlerFile := results["task-cancel-handler.ts"]
	isMultiFile := hasHandlerFile

	var sb strings.Builder

	if isMultiFile {
		// Multi-file: create tasks.ts with imports
		sb.WriteString("// Code generated by aprot. DO NOT EDIT.\n\n")
		if mode == aprot.OutputReact {
			sb.WriteString("import { useState, useEffect, useCallback } from 'react';\n")
			sb.WriteString("import type { ApiClient } from './client';\n")
			sb.WriteString("import { useApiClient } from './client';\n")
			sb.WriteString("import type { SharedTaskState, TaskStateEvent, TaskUpdateEvent } from './task-cancel-handler';\n")
		} else {
			sb.WriteString("import type { ApiClient } from './client';\n")
			sb.WriteString("import type { SharedTaskState, TaskStateEvent, TaskUpdateEvent } from './task-cancel-handler';\n")
		}
		sb.WriteString("\n")
	} else {
		// Single-file: append to client.ts (all types already in scope)
		// For React mode, ensure useCallback is imported (used by useTaskOutput hook)
		if mode == aprot.OutputReact {
			results["client.ts"] = strings.Replace(
				results["client.ts"],
				"import { useState, useEffect, useContext, createContext } from 'react';",
				"import { useState, useEffect, useCallback, useContext, createContext } from 'react';",
				1,
			)
		}
		sb.WriteString("\n")
	}

	// cancelSharedTask function
	sb.WriteString("export function cancelSharedTask(client: ApiClient, taskId: string): Promise<void> {\n")
	sb.WriteString("    return client.request<void>('taskCancelHandler.CancelTask', [{ taskId }]);\n")
	sb.WriteString("}\n")

	if mode == aprot.OutputReact {
		sb.WriteString("\n// Shared task hooks\n")
		sb.WriteString("export function useSharedTasks(): SharedTaskState[] {\n")
		sb.WriteString("    const client = useApiClient();\n")
		sb.WriteString("    const [tasks, setTasks] = useState<SharedTaskState[]>([]);\n\n")
		sb.WriteString("    useEffect(() => {\n")
		sb.WriteString("        return client.onPush<TaskStateEvent>('TaskStateEvent', (event) => {\n")
		sb.WriteString("            setTasks(event.tasks);\n")
		sb.WriteString("        });\n")
		sb.WriteString("    }, [client]);\n\n")
		sb.WriteString("    return tasks;\n")
		sb.WriteString("}\n\n")

		sb.WriteString("export function useSharedTask(id: string): SharedTaskState | null {\n")
		sb.WriteString("    const tasks = useSharedTasks();\n")
		sb.WriteString("    return tasks.find(t => t.id === id) ?? null;\n")
		sb.WriteString("}\n\n")

		sb.WriteString("export function useMyTasks(): SharedTaskState[] {\n")
		sb.WriteString("    const tasks = useSharedTasks();\n")
		sb.WriteString("    return tasks.filter(t => t.isOwner && !t.parentId);\n")
		sb.WriteString("}\n\n")

		sb.WriteString("export function useTaskOutput(taskId: string): { lines: string[]; clear: () => void } {\n")
		sb.WriteString("    const client = useApiClient();\n")
		sb.WriteString("    const [lines, setLines] = useState<string[]>([]);\n\n")
		sb.WriteString("    useEffect(() => {\n")
		sb.WriteString("        return client.onPush<TaskUpdateEvent>('TaskUpdateEvent', (event) => {\n")
		sb.WriteString("            if (event.taskId === taskId && event.output != null) {\n")
		sb.WriteString("                setLines((prev) => [...prev, event.output!]);\n")
		sb.WriteString("            }\n")
		sb.WriteString("        });\n")
		sb.WriteString("    }, [client, taskId]);\n\n")
		sb.WriteString("    const clear = useCallback(() => setLines([]), []);\n\n")
		sb.WriteString("    return { lines, clear };\n")
		sb.WriteString("}\n")
	}

	// Meta type overrides
	if metaType != nil {
		sb.WriteString("\n")
		generateMetaInterfaces(&sb, metaType)
	}

	code := sb.String()

	if isMultiFile {
		results["tasks.ts"] = code
	} else {
		results["client.ts"] += code
	}
}

var timeType = reflect.TypeOf(time.Time{})

// generateMetaInterfaces writes TypeScript interfaces for the meta type using reflection.
func generateMetaInterfaces(sb *strings.Builder, t reflect.Type) {
	if t.Kind() == reflect.Ptr {
		t = t.Elem()
	}
	if t.Kind() != reflect.Struct {
		return
	}

	// Collect nested types first (depth-first so dependencies come first)
	var nested []reflect.Type
	collectNestedStructs(t, &nested, map[reflect.Type]bool{})

	// Write nested interfaces first
	for _, nt := range nested {
		writeInterface(sb, nt)
	}

	// Write the main interface
	writeInterface(sb, t)
}

func collectNestedStructs(t reflect.Type, nested *[]reflect.Type, seen map[reflect.Type]bool) {
	if seen[t] {
		return
	}
	seen[t] = true

	for i := 0; i < t.NumField(); i++ {
		field := t.Field(i)
		if !field.IsExported() {
			continue
		}
		if field.Tag.Get("json") == "-" {
			continue
		}
		ft := field.Type
		if ft.Kind() == reflect.Ptr {
			ft = ft.Elem()
		}
		if ft.Kind() == reflect.Slice {
			ft = ft.Elem()
			if ft.Kind() == reflect.Ptr {
				ft = ft.Elem()
			}
		}
		if ft.Kind() == reflect.Struct && ft.PkgPath() != "" && ft != timeType {
			collectNestedStructs(ft, nested, seen)
			*nested = append(*nested, ft)
		}
	}
}

func writeInterface(sb *strings.Builder, t reflect.Type) {
	sb.WriteString("export interface ")
	sb.WriteString(t.Name())
	sb.WriteString(" {\n")

	for i := 0; i < t.NumField(); i++ {
		field := t.Field(i)
		if !field.IsExported() {
			continue
		}
		tag := field.Tag.Get("json")
		if tag == "-" {
			continue
		}

		name := field.Name
		optional := false
		if tag != "" {
			parts := strings.Split(tag, ",")
			if parts[0] != "" {
				name = parts[0]
			}
			for _, opt := range parts[1:] {
				if opt == "omitempty" {
					optional = true
				}
			}
		}
		if field.Type.Kind() == reflect.Ptr {
			optional = true
		}

		sb.WriteString("    ")
		sb.WriteString(name)
		if optional {
			sb.WriteString("?")
		}
		sb.WriteString(": ")
		sb.WriteString(goTypeToTS(field.Type))
		sb.WriteString(";\n")
	}

	sb.WriteString("}\n")
}

func goTypeToTS(t reflect.Type) string {
	if t.Kind() == reflect.Ptr {
		return goTypeToTS(t.Elem())
	}
	switch t.Kind() {
	case reflect.String:
		return "string"
	case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64,
		reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64,
		reflect.Float32, reflect.Float64:
		return "number"
	case reflect.Bool:
		return "boolean"
	case reflect.Slice:
		return goTypeToTS(t.Elem()) + "[]"
	case reflect.Map:
		return fmt.Sprintf("Record<%s, %s>", goTypeToTS(t.Key()), goTypeToTS(t.Elem()))
	case reflect.Struct:
		if t == timeType {
			return "string"
		}
		if t.PkgPath() == "" {
			return "any"
		}
		return t.Name()
	case reflect.Interface:
		return "any"
	default:
		return "any"
	}
}
