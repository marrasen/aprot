{{- /* Common TypeScript code shared between vanilla and React templates */ -}}

{{define "error-codes"}}
// Standard error codes
export const ErrorCode = {
    ParseError: -32700,
    InvalidRequest: -32600,
    MethodNotFound: -32601,
    InvalidParams: -32602,
    InternalError: -32603,
    Canceled: -32800,
    Unauthorized: -32001,
    ConnectionRejected: -32002,
    Forbidden: -32003,
{{- range .CustomErrorCodes}}
    {{.Name}}: {{.Code}},
{{- end}}
} as const;

export type ErrorCodeType = typeof ErrorCode[keyof typeof ErrorCode];
{{end}}

{{define "api-error"}}
// ApiError is thrown when the server returns an error response
export class ApiError extends Error {
    readonly code: number;

    constructor(code: number, message: string) {
        super(message);
        this.name = 'ApiError';
        this.code = code;
    }

    // Helper methods for checking error types
    isUnauthorized(): boolean { return this.code === ErrorCode.Unauthorized; }
    isForbidden(): boolean { return this.code === ErrorCode.Forbidden; }
    isNotFound(): boolean { return this.code === ErrorCode.MethodNotFound; }
    isInvalidParams(): boolean { return this.code === ErrorCode.InvalidParams; }
    isCanceled(): boolean { return this.code === ErrorCode.Canceled; }
    isConnectionRejected(): boolean { return this.code === ErrorCode.ConnectionRejected; }
{{- range .CustomErrorCodes}}
    {{.MethodName}}(): boolean { return this.code === ErrorCode.{{.Name}}; }
{{- end}}
}
{{end}}

{{define "types"}}
{{- range .TaskMetaInterfaces}}
export interface {{.Name}} {
{{- range .Fields}}
    {{.Name}}{{if .Optional}}?{{end}}: {{.Type}};
{{- end}}
}

{{end -}}
export const TaskNodeStatus = {
    Running: "running",
    Completed: "completed",
    Failed: "failed",
} as const;
export type TaskNodeStatusType = typeof TaskNodeStatus[keyof typeof TaskNodeStatus];

export interface TaskNode {
    id: string;
    title: string;
    status: TaskNodeStatusType;
    error?: string;
    current?: number;
    total?: number;
{{- if .TaskMetaType}}
    meta?: {{.TaskMetaType}};
{{- end}}
    children?: TaskNode[];
}

export interface RequestOptions {
    signal?: AbortSignal;
    onProgress?: (current: number, total: number, message: string) => void;
    onTaskProgress?: (tasks: TaskNode[]) => void;
    onOutput?: (output: string, taskId?: string) => void;
}
{{- if .HasTasks}}

export interface SharedTaskState {
    id: string;
    parentId?: string;
    title: string;
    status: TaskNodeStatusType;
    error?: string;
    current?: number;
    total?: number;
    isOwner: boolean;
{{- if .TaskMetaType}}
    meta?: {{.TaskMetaType}};
{{- end}}
    children?: TaskNode[];
}

export interface TaskRef {
    taskId: string;
}
{{- end}}

export type PushHandler<T> = (data: T) => void;

export type ConnectionState = 'disconnected' | 'connecting' | 'connected' | 'reconnecting';

export interface ApiClientOptions {
    /** Transport type. Default: 'websocket' */
    transport?: 'websocket' | 'sse';
    /** Enable auto-reconnect on connection loss. Default: true */
    reconnect?: boolean;
    /** Initial reconnect delay in ms. Default: 1000 */
    reconnectInterval?: number;
    /** Maximum reconnect delay in ms (for exponential backoff). Default: 30000 */
    reconnectMaxInterval?: number;
    /** Maximum reconnect attempts. 0 = unlimited. Default: 0 */
    reconnectMaxAttempts?: number;
    /** Heartbeat interval in ms. 0 = disabled. Default: 30000 */
    heartbeatInterval?: number;
    /** Heartbeat timeout in ms. Default: 5000 */
    heartbeatTimeout?: number;
    /** Called when the server rejects the connection (e.g. invalid session). Connection will not auto-reconnect. */
    onConnectionRejected?: (error: ApiError) => void;
}

type ResolvedOptions = Required<Omit<ApiClientOptions, 'onConnectionRejected'>> & Pick<ApiClientOptions, 'onConnectionRejected'>;

const defaultOptions: ResolvedOptions = {
    transport: 'websocket',
    reconnect: true,
    reconnectInterval: 1000,
    reconnectMaxInterval: 30000,
    reconnectMaxAttempts: 0,
    heartbeatInterval: 30000,
    heartbeatTimeout: 5000,
};
{{end}}

{{define "get-websocket-url"}}
/**
 * Returns a WebSocket URL based on the current page location.
 * Automatically uses wss: for https: pages and ws: for http: pages.
 * @param path - The WebSocket endpoint path (default: '/ws')
 */
export function getWebSocketUrl(path: string = '/ws'): string {
    const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
    return `${protocol}//${window.location.host}${path}`;
}

/**
 * Returns an SSE base URL based on the current page location.
 * @param path - The SSE endpoint base path (default: '/sse')
 */
export function getSSEUrl(path: string = '/sse'): string {
    return `${window.location.protocol}//${window.location.host}${path}`;
}
{{end}}

{{define "api-client-class"}}
// Internal transport interface
interface ClientTransport {
    connect(url: string, onMessage: (data: string) => void, onClose: () => void): Promise<void>;
    send(message: object): void;
    disconnect(): void;
    isConnected(): boolean;
}

class WebSocketTransport implements ClientTransport {
    private ws: WebSocket | null = null;

    connect(url: string, onMessage: (data: string) => void, onClose: () => void): Promise<void> {
        return new Promise((resolve) => {
            this.ws = new WebSocket(url);
            this.ws.onopen = () => resolve();
            this.ws.onerror = () => {}; // Error is followed by close
            this.ws.onmessage = (e) => onMessage(e.data);
            this.ws.onclose = () => {
                this.ws = null;
                onClose();
            };
        });
    }

    send(message: object): void {
        this.ws?.send(JSON.stringify(message));
    }

    disconnect(): void {
        this.ws?.close();
        this.ws = null;
    }

    isConnected(): boolean {
        return this.ws !== null && this.ws.readyState === WebSocket.OPEN;
    }
}

type ClientMessage =
    | { type: 'request'; id: string; method: string; params: unknown[] }
    | { type: 'cancel'; id: string }
    | { type: 'ping' };

class SSETransport implements ClientTransport {
    private eventSource: EventSource | null = null;
    private connectionId: string | null = null;
    private baseUrl: string = '';
    private onMessage: ((data: string) => void) | null = null;

    connect(url: string, onMessage: (data: string) => void, onClose: () => void): Promise<void> {
        this.baseUrl = url;
        this.onMessage = onMessage;

        return new Promise((resolve) => {
            this.eventSource = new EventSource(url);

            this.eventSource.addEventListener('connected', (e: MessageEvent) => {
                const msg = JSON.parse(e.data);
                this.connectionId = msg.connectionId;
                resolve();
            });

            this.eventSource.addEventListener('config', (e: MessageEvent) => {
                onMessage(e.data);
            });

            this.eventSource.addEventListener('response', (e: MessageEvent) => {
                onMessage(e.data);
            });

            this.eventSource.addEventListener('error', (e: MessageEvent) => {
                if (e.data) {
                    onMessage(e.data);
                } else {
                    // EventSource connection error (no data = connectivity issue)
                    this.eventSource?.close();
                    this.eventSource = null;
                    this.connectionId = null;
                    onClose();
                }
            });

            this.eventSource.addEventListener('progress', (e: MessageEvent) => {
                onMessage(e.data);
            });

            this.eventSource.addEventListener('push', (e: MessageEvent) => {
                onMessage(e.data);
            });
        });
    }

    send(message: object): void {
        if (!this.connectionId) return;
        const msg = message as ClientMessage;

        if (msg.type === 'request') {
            fetch(this.baseUrl + '/rpc', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    connectionId: this.connectionId,
                    id: msg.id,
                    method: msg.method,
                    params: msg.params,
                }),
            }).then((resp) => {
                if (resp.status !== 202) {
                    this.synthesizeError(msg.id, `Server returned unexpected response (status ${resp.status})`);
                }
            }).catch(() => {
                this.synthesizeError(msg.id, 'Network error: failed to send request');
            });
        } else if (msg.type === 'cancel') {
            fetch(this.baseUrl + '/cancel', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    connectionId: this.connectionId,
                    id: msg.id,
                }),
            }).catch(() => {});
        }
        // ping is a no-op for SSE (server uses keep-alive comments)
    }

    private synthesizeError(id: string, message: string): void {
        if (this.onMessage) {
            this.onMessage(JSON.stringify({ type: 'error', id, code: -32603, message }));
        }
    }

    disconnect(): void {
        this.eventSource?.close();
        this.eventSource = null;
        this.connectionId = null;
        this.onMessage = null;
    }

    isConnected(): boolean {
        return this.eventSource !== null && this.connectionId !== null;
    }
}

export class ApiClient {
    private transport: ClientTransport;
    private url: string;
    private options: ResolvedOptions;
    private requestId = 0;
    private pending = new Map<string, {
        resolve: (value: unknown) => void;
        reject: (error: Error) => void;
        onProgress?: (current: number, total: number, message: string) => void;
        onTaskProgress?: (tasks: TaskNode[]) => void;
        onOutput?: (output: string, taskId?: string) => void;
    }>();
    private buffer: Array<{
        method: string;
        params: unknown[];
        options?: RequestOptions;
        resolve: (value: unknown) => void;
        reject: (error: Error) => void;
    }> = [];
    private pushHandlers = new Map<string, Set<(data: unknown) => void>>();
    private stateListeners = new Set<(state: ConnectionState) => void>();
    private state: ConnectionState = 'disconnected';
    private reconnectAttempts = 0;
    private reconnectTimer: ReturnType<typeof setTimeout> | null = null;
    private heartbeatTimer: ReturnType<typeof setInterval> | null = null;
    private heartbeatPending = false;
    private manualDisconnect = false;

    constructor(url: string, options?: ApiClientOptions) {
        this.url = url;
        this.options = { ...defaultOptions, ...options };
        this.transport = this.options.transport === 'sse'
            ? new SSETransport()
            : new WebSocketTransport();
    }

    connect(): Promise<void> {
        if (this.state === 'connected' || this.state === 'connecting') {
            return Promise.resolve();
        }
        this.manualDisconnect = false;
        return this.doConnect();
    }

    private doConnect(): Promise<void> {
        this.setState(this.reconnectAttempts > 0 ? 'reconnecting' : 'connecting');

        return this.transport.connect(
            this.url,
            (data) => this.handleMessage(data),
            () => this.handleClose(),
        ).then(() => {
            this.reconnectAttempts = 0;
            this.setState('connected');
            if (this.options.transport !== 'sse') {
                this.startHeartbeat();
            }
        }).catch(() => {
            this.handleClose();
        });
    }

    private handleClose(): void {
        this.stopHeartbeat();

        // Reject all pending requests
        for (const [, p] of this.pending) {
            p.reject(new Error('Connection closed'));
        }
        this.pending.clear();

        if (this.manualDisconnect) {
            this.setState('disconnected');
            return;
        }

        // Auto-reconnect if enabled
        if (this.options.reconnect && (
            this.options.reconnectMaxAttempts === 0 ||
            this.reconnectAttempts < this.options.reconnectMaxAttempts
        )) {
            this.scheduleReconnect();
        } else {
            this.setState('disconnected');
        }
    }

    private scheduleReconnect(): void {
        if (this.reconnectTimer) return;

        const delay = Math.min(
            this.options.reconnectInterval * Math.pow(2, this.reconnectAttempts),
            this.options.reconnectMaxInterval
        );
        this.reconnectAttempts++;
        this.setState('reconnecting');

        this.reconnectTimer = setTimeout(() => {
            this.reconnectTimer = null;
            this.doConnect().catch(() => {
                // Error handled in handleClose
            });
        }, delay);
    }

    disconnect(): void {
        this.manualDisconnect = true;
        this.stopHeartbeat();
        if (this.reconnectTimer) {
            clearTimeout(this.reconnectTimer);
            this.reconnectTimer = null;
        }
        this.transport.disconnect();
        this.setState('disconnected');
    }

    getState(): ConnectionState {
        return this.state;
    }

    private setState(state: ConnectionState): void {
        if (this.state === state) return;
        this.state = state;
        if (state === 'connected') {
            this.flushBuffer();
        } else if (state === 'disconnected') {
            this.rejectBuffer(new Error('Not connected'));
        }
        for (const listener of this.stateListeners) {
            listener(state);
        }
    }

    onStateChange(listener: (state: ConnectionState) => void): () => void {
        this.stateListeners.add(listener);
        return () => this.stateListeners.delete(listener);
    }

    /** @deprecated Use onStateChange instead */
    onConnectionChange(listener: (connected: boolean) => void): () => void {
        const wrapper = (state: ConnectionState) => listener(state === 'connected');
        this.stateListeners.add(wrapper);
        return () => this.stateListeners.delete(wrapper);
    }

    isConnected(): boolean {
        return this.state === 'connected';
    }

    private startHeartbeat(): void {
        if (this.options.heartbeatInterval <= 0) return;

        this.heartbeatTimer = setInterval(() => {
            if (!this.transport.isConnected()) return;

            if (this.heartbeatPending) {
                // Previous ping not answered, connection is dead
                this.transport.disconnect();
                return;
            }

            this.heartbeatPending = true;
            this.transport.send({ type: 'ping' });

            // Set timeout for pong response
            setTimeout(() => {
                if (this.heartbeatPending && this.transport.isConnected()) {
                    this.transport.disconnect();
                }
            }, this.options.heartbeatTimeout);
        }, this.options.heartbeatInterval);
    }

    private stopHeartbeat(): void {
        if (this.heartbeatTimer) {
            clearInterval(this.heartbeatTimer);
            this.heartbeatTimer = null;
        }
        this.heartbeatPending = false;
    }

    private handleMessage(data: string): void {
        const msg = JSON.parse(data);
        switch (msg.type) {
            case 'config':
                this.applyConfig(msg);
                break;
            case 'pong':
                this.heartbeatPending = false;
                break;
            case 'response': {
                const p = this.pending.get(msg.id);
                if (p) {
                    this.pending.delete(msg.id);
                    p.resolve(msg.result);
                }
                break;
            }
            case 'error': {
                const p = this.pending.get(msg.id);
                if (p) {
                    this.pending.delete(msg.id);
                    p.reject(new ApiError(msg.code, msg.message));
                } else if (msg.code === ErrorCode.ConnectionRejected) {
                    this.manualDisconnect = true;
                    this.options.onConnectionRejected?.(new ApiError(msg.code, msg.message));
                    this.transport.disconnect();
                }
                break;
            }
            case 'progress': {
                const p = this.pending.get(msg.id);
                if (p) {
                    if (msg.tasks && p.onTaskProgress) {
                        p.onTaskProgress(msg.tasks);
                    }
                    if (msg.output != null && p.onOutput) {
                        p.onOutput(msg.output, msg.taskId);
                    }
                    if (p.onProgress && (msg.current != null || msg.total != null || msg.message)) {
                        p.onProgress(msg.current ?? 0, msg.total ?? 0, msg.message ?? '');
                    }
                }
                break;
            }
            case 'push': {
                const handlers = this.pushHandlers.get(msg.event);
                if (handlers) {
                    for (const handler of handlers) {
                        handler(msg.data);
                    }
                }
                break;
            }
        }
    }

    private applyConfig(config: {
        reconnectInterval?: number;
        reconnectMaxInterval?: number;
        reconnectMaxAttempts?: number;
        heartbeatInterval?: number;
        heartbeatTimeout?: number;
    }): void {
        if (config.reconnectInterval !== undefined) {
            this.options.reconnectInterval = config.reconnectInterval;
        }
        if (config.reconnectMaxInterval !== undefined) {
            this.options.reconnectMaxInterval = config.reconnectMaxInterval;
        }
        if (config.reconnectMaxAttempts !== undefined) {
            this.options.reconnectMaxAttempts = config.reconnectMaxAttempts;
        }
        if (config.heartbeatInterval !== undefined) {
            this.options.heartbeatInterval = config.heartbeatInterval;
            // Restart heartbeat with new interval if already running
            if (this.heartbeatTimer) {
                this.stopHeartbeat();
                this.startHeartbeat();
            }
        }
        if (config.heartbeatTimeout !== undefined) {
            this.options.heartbeatTimeout = config.heartbeatTimeout;
        }
    }

    request<T>(method: string, params: unknown[], options?: RequestOptions): Promise<T> {
        return new Promise((resolve, reject) => {
            const res = resolve as (value: unknown) => void;
            if (this.transport.isConnected()) {
                this.sendRequest(method, params, options, res, reject);
                return;
            }
            if (this.state === 'connecting' || this.state === 'reconnecting') {
                const entry = { method, params, options, resolve: res, reject };
                this.buffer.push(entry);
                if (options?.signal) {
                    if (options.signal.aborted) {
                        this.buffer.pop();
                        reject(new Error('Request aborted'));
                        return;
                    }
                    options.signal.addEventListener('abort', () => {
                        const idx = this.buffer.indexOf(entry);
                        if (idx !== -1) {
                            this.buffer.splice(idx, 1);
                            reject(new Error('Request aborted'));
                        }
                    }, { once: true });
                }
                return;
            }
            reject(new Error('Not connected'));
        });
    }

    private sendRequest(method: string, params: unknown[], options: RequestOptions | undefined,
        resolve: (value: unknown) => void, reject: (error: Error) => void): void {
        const id = String(++this.requestId);
        this.pending.set(id, {
            resolve, reject,
            onProgress: options?.onProgress,
            onTaskProgress: options?.onTaskProgress,
            onOutput: options?.onOutput,
        });
        if (options?.signal) {
            if (options.signal.aborted) {
                this.pending.delete(id);
                reject(new Error('Request aborted'));
                return;
            }
            options.signal.addEventListener('abort', () => {
                this.transport.send({ type: 'cancel', id });
                this.pending.delete(id);
                reject(new Error('Request aborted'));
            }, { once: true });
        }
        this.transport.send({ type: 'request', id, method, params });
    }

    private flushBuffer(): void {
        const buffered = this.buffer;
        this.buffer = [];
        for (const entry of buffered) {
            if (entry.options?.signal?.aborted) {
                entry.reject(new Error('Request aborted'));
                continue;
            }
            this.sendRequest(entry.method, entry.params, entry.options, entry.resolve, entry.reject);
        }
    }

    private rejectBuffer(error: Error): void {
        const buffered = this.buffer;
        this.buffer = [];
        for (const entry of buffered) {
            entry.reject(error);
        }
    }

    onPush<T>(event: string, handler: PushHandler<T>): () => void {
        if (!this.pushHandlers.has(event)) {
            this.pushHandlers.set(event, new Set());
        }
        const cb = handler as (data: unknown) => void;
        this.pushHandlers.get(event)!.add(cb);
        return () => {
            this.pushHandlers.get(event)?.delete(cb);
        };
    }
}
{{end}}

{{define "enums"}}
{{- range .Enums}}
export const {{.Name}} = {
{{- range .Values}}
    {{.Name}}: {{.Value}},
{{- end}}
} as const;
export type {{.Name}}Type = typeof {{.Name}}[keyof typeof {{.Name}}];

{{end -}}
{{end}}

{{define "interfaces"}}
{{- range .Interfaces}}
export interface {{.Name}} {
{{- range .Fields}}
    {{.Name}}{{if .Optional}}?{{end}}: {{.Type}};
{{- end}}
}

{{end -}}
{{end}}

{{define "react-context"}}
// React Context
const ApiClientContext = createContext<ApiClient | null>(null);

export const ApiClientProvider = ApiClientContext.Provider;

export function useApiClient(): ApiClient {
    const client = useContext(ApiClientContext);
    if (!client) {
        throw new Error('useApiClient must be used within an ApiClientProvider');
    }
    return client;
}

// Connection state hook
export function useConnectionState(): ConnectionState {
    const client = useApiClient();
    const [state, setState] = useState<ConnectionState>(client.getState());

    useEffect(() => {
        return client.onStateChange(setState);
    }, [client]);

    return state;
}

// Connection hook (convenience wrapper)
export function useConnection(): { isConnected: boolean; state: ConnectionState } {
    const state = useConnectionState();
    return { isConnected: state === 'connected', state };
}
{{end}}

{{define "react-hook-types"}}
// Query hook options
export interface UseQueryOptions<TReq> {
    params: TReq;
    enabled?: boolean;
    refetchInterval?: number;
}

// Query hook result
export interface UseQueryResult<TRes> {
    data: TRes | null;
    error: Error | null;
    isLoading: boolean;
    refetch: () => void;
    mutate: (action: Promise<unknown> | (() => Promise<unknown>)) => Promise<void>;
}

// Mutation hook options
export interface UseMutationOptions {
    onProgress?: (current: number, total: number, message: string) => void;
}

// Mutation hook result
export interface UseMutationResult<TParams extends unknown[], TRes> {
    mutate: (...params: TParams) => Promise<TRes>;
    data: TRes | null;
    error: Error | null;
    isLoading: boolean;
    reset: () => void;
}

// Push event hook result
export interface UsePushResult<T> {
    lastEvent: T | null;
    events: T[];
    clear: () => void;
}
{{end}}
