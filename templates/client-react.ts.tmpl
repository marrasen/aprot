// Code generated by aprot. DO NOT EDIT.

import { useState, useEffect, useCallback, useRef, useContext, createContext } from 'react';

{{template "enums" .}}
{{template "interfaces" .}}
{{template "error-codes" .}}

{{template "api-error" .}}

{{template "types" .}}

{{template "get-websocket-url" .}}

export class ApiClient {
    private ws: WebSocket | null = null;
    private url: string;
    private options: Required<ApiClientOptions>;
    private requestId = 0;
    private pending = new Map<string, {
        resolve: (value: any) => void;
        reject: (error: Error) => void;
        onProgress?: (current: number, total: number, message: string) => void;
    }>();
    private pushHandlers = new Map<string, Set<(data: any) => void>>();
    private stateListeners = new Set<(state: ConnectionState) => void>();
    private state: ConnectionState = 'disconnected';
    private reconnectAttempts = 0;
    private reconnectTimer: ReturnType<typeof setTimeout> | null = null;
    private heartbeatTimer: ReturnType<typeof setInterval> | null = null;
    private heartbeatPending = false;
    private manualDisconnect = false;

    constructor(url: string, options?: ApiClientOptions) {
        this.url = url;
        this.options = { ...defaultOptions, ...options };
    }

    connect(): Promise<void> {
        if (this.state === 'connected' || this.state === 'connecting') {
            return Promise.resolve();
        }
        this.manualDisconnect = false;
        return this.doConnect();
    }

    private doConnect(): Promise<void> {
        return new Promise((resolve, reject) => {
            this.setState(this.reconnectAttempts > 0 ? 'reconnecting' : 'connecting');
            this.ws = new WebSocket(this.url);

            this.ws.onopen = () => {
                this.reconnectAttempts = 0;
                this.setState('connected');
                this.startHeartbeat();
                resolve();
            };

            this.ws.onerror = () => {
                // Error is followed by close, so we handle reconnect there
            };

            this.ws.onmessage = (e) => this.handleMessage(e.data);

            this.ws.onclose = () => {
                this.stopHeartbeat();
                const wasConnected = this.state === 'connected';

                // Reject all pending requests
                for (const [, p] of this.pending) {
                    p.reject(new Error('Connection closed'));
                }
                this.pending.clear();

                if (this.manualDisconnect) {
                    this.setState('disconnected');
                    return;
                }

                // Auto-reconnect if enabled
                if (this.options.reconnect && (
                    this.options.reconnectMaxAttempts === 0 ||
                    this.reconnectAttempts < this.options.reconnectMaxAttempts
                )) {
                    this.scheduleReconnect();
                } else {
                    this.setState('disconnected');
                    if (!wasConnected) {
                        reject(new Error('Connection failed'));
                    }
                }
            };
        });
    }

    private scheduleReconnect(): void {
        if (this.reconnectTimer) return;

        const delay = Math.min(
            this.options.reconnectInterval * Math.pow(2, this.reconnectAttempts),
            this.options.reconnectMaxInterval
        );
        this.reconnectAttempts++;
        this.setState('reconnecting');

        this.reconnectTimer = setTimeout(() => {
            this.reconnectTimer = null;
            this.doConnect().catch(() => {
                // Error handled in onclose
            });
        }, delay);
    }

    disconnect(): void {
        this.manualDisconnect = true;
        this.stopHeartbeat();
        if (this.reconnectTimer) {
            clearTimeout(this.reconnectTimer);
            this.reconnectTimer = null;
        }
        this.ws?.close();
        this.ws = null;
        this.setState('disconnected');
    }

    getState(): ConnectionState {
        return this.state;
    }

    private setState(state: ConnectionState): void {
        if (this.state === state) return;
        this.state = state;
        for (const listener of this.stateListeners) {
            listener(state);
        }
    }

    onStateChange(listener: (state: ConnectionState) => void): () => void {
        this.stateListeners.add(listener);
        return () => this.stateListeners.delete(listener);
    }

    /** @deprecated Use onStateChange instead */
    onConnectionChange(listener: (connected: boolean) => void): () => void {
        const wrapper = (state: ConnectionState) => listener(state === 'connected');
        this.stateListeners.add(wrapper);
        return () => this.stateListeners.delete(wrapper);
    }

    isConnected(): boolean {
        return this.state === 'connected';
    }

    private startHeartbeat(): void {
        if (this.options.heartbeatInterval <= 0) return;

        this.heartbeatTimer = setInterval(() => {
            if (!this.ws || this.ws.readyState !== WebSocket.OPEN) return;

            if (this.heartbeatPending) {
                // Previous ping not answered, connection is dead
                this.ws.close();
                return;
            }

            this.heartbeatPending = true;
            this.ws.send(JSON.stringify({ type: 'ping' }));

            // Set timeout for pong response
            setTimeout(() => {
                if (this.heartbeatPending && this.ws) {
                    this.ws.close();
                }
            }, this.options.heartbeatTimeout);
        }, this.options.heartbeatInterval);
    }

    private stopHeartbeat(): void {
        if (this.heartbeatTimer) {
            clearInterval(this.heartbeatTimer);
            this.heartbeatTimer = null;
        }
        this.heartbeatPending = false;
    }

    private handleMessage(data: string): void {
        const msg = JSON.parse(data);
        switch (msg.type) {
            case 'pong':
                this.heartbeatPending = false;
                break;
            case 'response': {
                const p = this.pending.get(msg.id);
                if (p) {
                    this.pending.delete(msg.id);
                    p.resolve(msg.result);
                }
                break;
            }
            case 'error': {
                const p = this.pending.get(msg.id);
                if (p) {
                    this.pending.delete(msg.id);
                    p.reject(new ApiError(msg.code, msg.message));
                }
                break;
            }
            case 'progress': {
                const p = this.pending.get(msg.id);
                if (p?.onProgress) {
                    p.onProgress(msg.current, msg.total, msg.message);
                }
                break;
            }
            case 'push': {
                const handlers = this.pushHandlers.get(msg.event);
                if (handlers) {
                    for (const handler of handlers) {
                        handler(msg.data);
                    }
                }
                break;
            }
        }
    }

    private request<T>(method: string, params: any, options?: RequestOptions): Promise<T> {
        return new Promise((resolve, reject) => {
            if (!this.ws || this.ws.readyState !== WebSocket.OPEN) {
                reject(new Error('Not connected'));
                return;
            }
            const id = String(++this.requestId);
            this.pending.set(id, { resolve, reject, onProgress: options?.onProgress });
            if (options?.signal) {
                options.signal.addEventListener('abort', () => {
                    this.ws?.send(JSON.stringify({ type: 'cancel', id }));
                    this.pending.delete(id);
                    reject(new Error('Request aborted'));
                });
            }
            this.ws.send(JSON.stringify({ type: 'request', id, method, params }));
        });
    }

    onPush<T>(event: string, handler: PushHandler<T>): () => void {
        if (!this.pushHandlers.has(event)) {
            this.pushHandlers.set(event, new Set());
        }
        this.pushHandlers.get(event)!.add(handler);
        return () => {
            this.pushHandlers.get(event)?.delete(handler);
        };
    }
{{range .Methods}}
    {{.MethodName}}(req: {{.RequestType}}, options?: RequestOptions): Promise<{{.ResponseType}}> {
        return this.request<{{.ResponseType}}>('{{.Name}}', req, options);
    }
{{end}}
{{- range .PushEvents}}
    {{.HandlerName}}(handler: PushHandler<{{.DataType}}>): () => void {
        return this.onPush<{{.DataType}}>('{{.Name}}', handler);
    }
{{end -}}
}

{{template "react-context" .}}

{{template "react-hook-types" .}}
{{range .Methods}}
// Hook for {{.Name}}
export function {{.HookName}}(options: UseQueryOptions<{{.RequestType}}>): UseQueryResult<{{.ResponseType}}> {
    const client = useApiClient();
    const [data, setData] = useState<{{.ResponseType}} | null>(null);
    const [error, setError] = useState<Error | null>(null);
    const [isLoading, setIsLoading] = useState(false);
    const paramsRef = useRef(options.params);
    paramsRef.current = options.params;

    const fetch = useCallback(async () => {
        if (options.enabled === false) return;
        setIsLoading(true);
        setError(null);
        try {
            const result = await client.{{.MethodName}}(paramsRef.current);
            setData(result);
        } catch (err) {
            setError(err as Error);
        } finally {
            setIsLoading(false);
        }
    }, [client, options.enabled]);

    useEffect(() => {
        fetch();
    }, [fetch]);

    useEffect(() => {
        if (options.refetchInterval && options.refetchInterval > 0) {
            const interval = setInterval(fetch, options.refetchInterval);
            return () => clearInterval(interval);
        }
    }, [fetch, options.refetchInterval]);

    const refetch = useCallback(() => {
        fetch();
    }, [fetch]);

    const mutate = useCallback(async (action: Promise<any> | (() => Promise<any>)) => {
        setIsLoading(true);
        setError(null);
        try {
            await (typeof action === 'function' ? action() : action);
            await fetch();
        } catch (err) {
            setError(err as Error);
        } finally {
            setIsLoading(false);
        }
    }, [fetch]);

    return { data, error, isLoading, refetch, mutate };
}

// Mutation hook for {{.Name}}
export function {{.HookName}}Mutation(options?: UseMutationOptions): UseMutationResult<{{.RequestType}}, {{.ResponseType}}> {
    const client = useApiClient();
    const [data, setData] = useState<{{.ResponseType}} | null>(null);
    const [error, setError] = useState<Error | null>(null);
    const [isLoading, setIsLoading] = useState(false);

    const mutate = useCallback(async (params: {{.RequestType}}): Promise<{{.ResponseType}}> => {
        setIsLoading(true);
        setError(null);
        try {
            const result = await client.{{.MethodName}}(params, {
                onProgress: options?.onProgress,
            });
            setData(result);
            return result;
        } catch (err) {
            setError(err as Error);
            throw err;
        } finally {
            setIsLoading(false);
        }
    }, [client, options?.onProgress]);

    const reset = useCallback(() => {
        setData(null);
        setError(null);
        setIsLoading(false);
    }, []);

    return { mutate, data, error, isLoading, reset };
}
{{end}}
{{- range .PushEvents}}
// Hook for {{.Name}} push events
export function {{.HookName}}(options?: { maxEvents?: number }): UsePushResult<{{.DataType}}> {
    const client = useApiClient();
    const [lastEvent, setLastEvent] = useState<{{.DataType}} | null>(null);
    const [events, setEvents] = useState<{{.DataType}}[]>([]);
    const maxEvents = options?.maxEvents ?? 100;

    useEffect(() => {
        return client.{{.HandlerName}}((data) => {
            setLastEvent(data);
            setEvents((prev) => {
                const next = [...prev, data];
                return next.length > maxEvents ? next.slice(-maxEvents) : next;
            });
        });
    }, [client, maxEvents]);

    const clear = useCallback(() => {
        setLastEvent(null);
        setEvents([]);
    }, []);

    return { lastEvent, events, clear };
}
{{end -}}
