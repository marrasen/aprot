// Code generated by aprot. DO NOT EDIT.
// Handler: {{.StructName}}

{{- if or .Methods .PushEvents}}
import { useState, useEffect, useCallback } from 'react';
import { ApiClient, useApiClient } from './client';
{{- else}}
import { ApiClient } from './client';
{{- end}}
{{- if or .Methods .PushEvents}}
import type {
{{- if .Methods}}
    RequestOptions,
{{- end}}
{{- if .PushEvents}}
    PushHandler,
{{- end}}
{{- if hasMethodsWithParams .Methods}}
    UseQueryOptions,
{{- end}}
{{- if .Methods}}
    UseQueryResult,
    UseMutationOptions,
    UseMutationResult,
{{- end}}
{{- if .PushEvents}}
    UsePushResult,
{{- end}}
} from './client';
{{- end}}

{{range .Enums -}}
export const {{.Name}} = {
{{- range .Values}}
    {{.Name}}: {{.Value}},
{{- end}}
} as const;
export type {{.Name}}Type = typeof {{.Name}}[keyof typeof {{.Name}}];

{{end -}}
{{range .Interfaces -}}
export interface {{.Name}} {
{{- range .Fields}}
    {{.Name}}{{if .Optional}}?{{end}}: {{.Type}};
{{- end}}
}

{{end -}}
{{range .Methods -}}
export function {{.MethodName}}(client: ApiClient{{if hasParams .Params}}, {{paramDecl .Params}}{{end}}, options?: RequestOptions): Promise<{{.ResponseType}}> {
    return client.request<{{.ResponseType}}>('{{.WireMethod}}', [{{paramArray .Params}}], options);
}

{{end -}}
{{range .PushEvents -}}
export function {{.HandlerName}}(client: ApiClient, handler: PushHandler<{{.DataType}}>): () => void {
    return client.onPush<{{.DataType}}>('{{.Name}}', handler);
}

{{end -}}
// React Hooks for {{.StructName}}
{{range .Methods}}
{{- if not (hasParams .Params)}}
// Query hook for {{.Name}}
export function {{.HookName}}(options?: { enabled?: boolean; refetchInterval?: number }): UseQueryResult<{{.ResponseType}}> {
    const client = useApiClient();
    const [data, setData] = useState<{{.ResponseType}} | null>(null);
    const [error, setError] = useState<Error | null>(null);
    const [isLoading, setIsLoading] = useState(false);

    const fetch = useCallback(async () => {
        if (options?.enabled === false) return;
        setIsLoading(true);
        setError(null);
        try {
            const result = await {{.MethodName}}(client);
            setData(result);
        } catch (err) {
            setError(err as Error);
        } finally {
            setIsLoading(false);
        }
    }, [client, options?.enabled]);

    useEffect(() => {
        fetch();
    }, [fetch]);

    useEffect(() => {
        if (options?.refetchInterval && options.refetchInterval > 0) {
            const interval = setInterval(fetch, options.refetchInterval);
            return () => clearInterval(interval);
        }
    }, [fetch, options?.refetchInterval]);

    const refetch = useCallback(() => {
        fetch();
    }, [fetch]);

    const mutate = useCallback(async (action: Promise<unknown> | (() => Promise<unknown>)) => {
        setIsLoading(true);
        setError(null);
        try {
            await (typeof action === 'function' ? action() : action);
            await fetch();
        } catch (err) {
            setError(err as Error);
        } finally {
            setIsLoading(false);
        }
    }, [fetch]);

    return { data, error, isLoading, refetch, mutate };
}

// Mutation hook for {{.Name}}
export function {{.HookName}}Mutation(options?: UseMutationOptions): UseMutationResult<[], {{.ResponseType}}> {
    const client = useApiClient();
    const [data, setData] = useState<{{.ResponseType}} | null>(null);
    const [error, setError] = useState<Error | null>(null);
    const [isLoading, setIsLoading] = useState(false);

    const mutate = useCallback(async (): Promise<{{.ResponseType}}> => {
        setIsLoading(true);
        setError(null);
        try {
            const result = await {{.MethodName}}(client, {
                onProgress: options?.onProgress,
            });
            setData(result);
            return result;
        } catch (err) {
            setError(err as Error);
            throw err;
        } finally {
            setIsLoading(false);
        }
    }, [client, options?.onProgress]);

    const reset = useCallback(() => {
        setData(null);
        setError(null);
        setIsLoading(false);
    }, []);

    return { mutate, data, error, isLoading, reset };
}
{{- else}}
// Query hook for {{.Name}}
export function {{.HookName}}(options: UseQueryOptions<[{{paramDecl .Params}}]>): UseQueryResult<{{.ResponseType}}> {
    const client = useApiClient();
    const [data, setData] = useState<{{.ResponseType}} | null>(null);
    const [error, setError] = useState<Error | null>(null);
    const [isLoading, setIsLoading] = useState(false);

    // Serialize params to detect changes
    const paramsKey = JSON.stringify(options.params);

    const fetch = useCallback(async () => {
        if (options.enabled === false) return;
        setIsLoading(true);
        setError(null);
        try {
            const result = await {{.MethodName}}(client, ...options.params);
            setData(result);
        } catch (err) {
            setError(err as Error);
        } finally {
            setIsLoading(false);
        }
    // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [client, options.enabled, paramsKey]);

    useEffect(() => {
        fetch();
    }, [fetch]);

    useEffect(() => {
        if (options.refetchInterval && options.refetchInterval > 0) {
            const interval = setInterval(fetch, options.refetchInterval);
            return () => clearInterval(interval);
        }
    }, [fetch, options.refetchInterval]);

    const refetch = useCallback(() => {
        fetch();
    }, [fetch]);

    const mutate = useCallback(async (action: Promise<unknown> | (() => Promise<unknown>)) => {
        setIsLoading(true);
        setError(null);
        try {
            await (typeof action === 'function' ? action() : action);
            await fetch();
        } catch (err) {
            setError(err as Error);
        } finally {
            setIsLoading(false);
        }
    }, [fetch]);

    return { data, error, isLoading, refetch, mutate };
}

// Mutation hook for {{.Name}}
export function {{.HookName}}Mutation(options?: UseMutationOptions): UseMutationResult<[{{paramDecl .Params}}], {{.ResponseType}}> {
    const client = useApiClient();
    const [data, setData] = useState<{{.ResponseType}} | null>(null);
    const [error, setError] = useState<Error | null>(null);
    const [isLoading, setIsLoading] = useState(false);

    const mutate = useCallback(async ({{paramDecl .Params}}): Promise<{{.ResponseType}}> => {
        setIsLoading(true);
        setError(null);
        try {
            const result = await {{.MethodName}}(client, {{paramNames .Params}}, {
                onProgress: options?.onProgress,
            });
            setData(result);
            return result;
        } catch (err) {
            setError(err as Error);
            throw err;
        } finally {
            setIsLoading(false);
        }
    }, [client, options?.onProgress]);

    const reset = useCallback(() => {
        setData(null);
        setError(null);
        setIsLoading(false);
    }, []);

    return { mutate, data, error, isLoading, reset };
}
{{- end}}
{{end}}
{{- range .PushEvents}}
// Push event hook for {{.Name}}
export function {{.HookName}}(options?: { maxEvents?: number }): UsePushResult<{{.DataType}}> {
    const client = useApiClient();
    const [lastEvent, setLastEvent] = useState<{{.DataType}} | null>(null);
    const [events, setEvents] = useState<{{.DataType}}[]>([]);
    const maxEvents = options?.maxEvents ?? 100;

    useEffect(() => {
        return {{.HandlerName}}(client, (data) => {
            setLastEvent(data);
            setEvents((prev) => {
                const next = [...prev, data];
                return next.length > maxEvents ? next.slice(-maxEvents) : next;
            });
        });
    }, [client, maxEvents]);

    const clear = useCallback(() => {
        setLastEvent(null);
        setEvents([]);
    }, []);

    return { lastEvent, events, clear };
}
{{end -}}
