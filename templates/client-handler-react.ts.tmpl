// Code generated by aprot. DO NOT EDIT.
// Handler: {{.StructName}}

import { useState, useEffect, useCallback, useRef } from 'react';
import {
    ApiClient,
    RequestOptions,
    PushHandler,
    useApiClient,
    UseQueryOptions,
    UseQueryResult,
    UseMutationOptions,
    UseMutationResult,
    UsePushResult,
} from './client';

{{range .Interfaces -}}
export interface {{.Name}} {
{{- range .Fields}}
    {{.Name}}{{if .Optional}}?{{end}}: {{.Type}};
{{- end}}
}

{{end -}}
// Extend ApiClient with {{.StructName}} methods
declare module './client' {
    interface ApiClient {
{{- range .Methods}}
        {{.MethodName}}(req: {{.RequestType}}, options?: RequestOptions): Promise<{{.ResponseType}}>;
{{- end}}
{{- range .PushEvents}}
        {{.HandlerName}}(handler: PushHandler<{{.DataType}}>): () => void;
{{- end}}
    }
}

{{range .Methods -}}
ApiClient.prototype.{{.MethodName}} = function(req: {{.RequestType}}, options?: RequestOptions): Promise<{{.ResponseType}}> {
    return this.request<{{.ResponseType}}>('{{.Name}}', req, options);
};

{{end -}}
{{range .PushEvents -}}
ApiClient.prototype.{{.HandlerName}} = function(handler: PushHandler<{{.DataType}}>): () => void {
    return this.onPush<{{.DataType}}>('{{.Name}}', handler);
};

{{end -}}
// React Hooks for {{.StructName}}
{{range .Methods}}
// Query hook for {{.Name}}
export function {{.HookName}}(options: UseQueryOptions<{{.RequestType}}>): UseQueryResult<{{.ResponseType}}> {
    const client = useApiClient();
    const [data, setData] = useState<{{.ResponseType}} | null>(null);
    const [error, setError] = useState<Error | null>(null);
    const [isLoading, setIsLoading] = useState(false);
    const paramsRef = useRef(options.params);
    paramsRef.current = options.params;

    const fetch = useCallback(async () => {
        if (options.enabled === false) return;
        setIsLoading(true);
        setError(null);
        try {
            const result = await client.{{.MethodName}}(paramsRef.current);
            setData(result);
        } catch (err) {
            setError(err as Error);
        } finally {
            setIsLoading(false);
        }
    }, [client, options.enabled]);

    useEffect(() => {
        fetch();
    }, [fetch]);

    useEffect(() => {
        if (options.refetchInterval && options.refetchInterval > 0) {
            const interval = setInterval(fetch, options.refetchInterval);
            return () => clearInterval(interval);
        }
    }, [fetch, options.refetchInterval]);

    const refetch = useCallback(() => {
        fetch();
    }, [fetch]);

    const mutate = useCallback((newData: {{.ResponseType}} | null) => {
        setData(newData);
    }, []);

    return { data, error, isLoading, refetch, mutate };
}

// Mutation hook for {{.Name}}
export function {{.HookName}}Mutation(options?: UseMutationOptions): UseMutationResult<{{.RequestType}}, {{.ResponseType}}> {
    const client = useApiClient();
    const [data, setData] = useState<{{.ResponseType}} | null>(null);
    const [error, setError] = useState<Error | null>(null);
    const [isLoading, setIsLoading] = useState(false);

    const mutate = useCallback(async (params: {{.RequestType}}): Promise<{{.ResponseType}}> => {
        setIsLoading(true);
        setError(null);
        try {
            const result = await client.{{.MethodName}}(params, {
                onProgress: options?.onProgress,
            });
            setData(result);
            return result;
        } catch (err) {
            setError(err as Error);
            throw err;
        } finally {
            setIsLoading(false);
        }
    }, [client, options?.onProgress]);

    const reset = useCallback(() => {
        setData(null);
        setError(null);
        setIsLoading(false);
    }, []);

    return { mutate, data, error, isLoading, reset };
}
{{end}}
{{- range .PushEvents}}
// Push event hook for {{.Name}}
export function {{.HookName}}(options?: { maxEvents?: number }): UsePushResult<{{.DataType}}> {
    const client = useApiClient();
    const [lastEvent, setLastEvent] = useState<{{.DataType}} | null>(null);
    const [events, setEvents] = useState<{{.DataType}}[]>([]);
    const maxEvents = options?.maxEvents ?? 100;

    useEffect(() => {
        return client.{{.HandlerName}}((data) => {
            setLastEvent(data);
            setEvents((prev) => {
                const next = [...prev, data];
                return next.length > maxEvents ? next.slice(-maxEvents) : next;
            });
        });
    }, [client, maxEvents]);

    const clear = useCallback(() => {
        setLastEvent(null);
        setEvents([]);
    }, []);

    return { lastEvent, events, clear };
}
{{end -}}
