// Code generated by aprot. DO NOT EDIT.

import { useState, useEffect, useContext, createContext } from 'react';

// Standard error codes
export const ErrorCode = {
    ParseError: -32700,
    InvalidRequest: -32600,
    MethodNotFound: -32601,
    InvalidParams: -32602,
    InternalError: -32603,
    Canceled: -32800,
    Unauthorized: -32001,
    Forbidden: -32003,
{{- range .CustomErrorCodes}}
    {{.Name}}: {{.Code}},
{{- end}}
} as const;

export type ErrorCodeType = typeof ErrorCode[keyof typeof ErrorCode];

// ApiError is thrown when the server returns an error response
export class ApiError extends Error {
    readonly code: number;

    constructor(code: number, message: string) {
        super(message);
        this.name = 'ApiError';
        this.code = code;
    }

    // Helper methods for checking error types
    isUnauthorized(): boolean { return this.code === ErrorCode.Unauthorized; }
    isForbidden(): boolean { return this.code === ErrorCode.Forbidden; }
    isNotFound(): boolean { return this.code === ErrorCode.MethodNotFound; }
    isInvalidParams(): boolean { return this.code === ErrorCode.InvalidParams; }
    isCanceled(): boolean { return this.code === ErrorCode.Canceled; }
{{- range .CustomErrorCodes}}
    {{.MethodName}}(): boolean { return this.code === ErrorCode.{{.Name}}; }
{{- end}}
}

export interface RequestOptions {
    signal?: AbortSignal;
    onProgress?: (current: number, total: number, message: string) => void;
}

export type PushHandler<T> = (data: T) => void;

/**
 * Returns a WebSocket URL based on the current page location.
 * Automatically uses wss: for https: pages and ws: for http: pages.
 * @param path - The WebSocket endpoint path (default: '/ws')
 */
export function getWebSocketUrl(path: string = '/ws'): string {
    const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
    return `${protocol}//${window.location.host}${path}`;
}

export class ApiClient {
    private ws: WebSocket | null = null;
    private url: string;
    private requestId = 0;
    private pending = new Map<string, {
        resolve: (value: any) => void;
        reject: (error: Error) => void;
        onProgress?: (current: number, total: number, message: string) => void;
    }>();
    private pushHandlers = new Map<string, Set<(data: any) => void>>();
    private connectionListeners = new Set<(connected: boolean) => void>();

    constructor(url: string) {
        this.url = url;
    }

    connect(): Promise<void> {
        return new Promise((resolve, reject) => {
            this.ws = new WebSocket(this.url);
            this.ws.onopen = () => {
                this.notifyConnectionChange(true);
                resolve();
            };
            this.ws.onerror = (e) => reject(e);
            this.ws.onmessage = (e) => this.handleMessage(e.data);
            this.ws.onclose = () => {
                for (const [, p] of this.pending) {
                    p.reject(new Error('Connection closed'));
                }
                this.pending.clear();
                this.notifyConnectionChange(false);
            };
        });
    }

    disconnect(): void {
        this.ws?.close();
        this.ws = null;
    }

    isConnected(): boolean {
        return this.ws?.readyState === WebSocket.OPEN;
    }

    onConnectionChange(listener: (connected: boolean) => void): () => void {
        this.connectionListeners.add(listener);
        return () => this.connectionListeners.delete(listener);
    }

    private notifyConnectionChange(connected: boolean): void {
        for (const listener of this.connectionListeners) {
            listener(connected);
        }
    }

    private handleMessage(data: string): void {
        const msg = JSON.parse(data);
        switch (msg.type) {
            case 'response': {
                const p = this.pending.get(msg.id);
                if (p) {
                    this.pending.delete(msg.id);
                    p.resolve(msg.result);
                }
                break;
            }
            case 'error': {
                const p = this.pending.get(msg.id);
                if (p) {
                    this.pending.delete(msg.id);
                    p.reject(new ApiError(msg.code, msg.message));
                }
                break;
            }
            case 'progress': {
                const p = this.pending.get(msg.id);
                if (p?.onProgress) {
                    p.onProgress(msg.current, msg.total, msg.message);
                }
                break;
            }
            case 'push': {
                const handlers = this.pushHandlers.get(msg.event);
                if (handlers) {
                    for (const handler of handlers) {
                        handler(msg.data);
                    }
                }
                break;
            }
        }
    }

    request<T>(method: string, params: any, options?: RequestOptions): Promise<T> {
        return new Promise((resolve, reject) => {
            if (!this.ws || this.ws.readyState !== WebSocket.OPEN) {
                reject(new Error('Not connected'));
                return;
            }
            const id = String(++this.requestId);
            this.pending.set(id, { resolve, reject, onProgress: options?.onProgress });
            if (options?.signal) {
                options.signal.addEventListener('abort', () => {
                    this.ws?.send(JSON.stringify({ type: 'cancel', id }));
                    this.pending.delete(id);
                    reject(new Error('Request aborted'));
                });
            }
            this.ws.send(JSON.stringify({ type: 'request', id, method, params }));
        });
    }

    onPush<T>(event: string, handler: PushHandler<T>): () => void {
        if (!this.pushHandlers.has(event)) {
            this.pushHandlers.set(event, new Set());
        }
        this.pushHandlers.get(event)!.add(handler);
        return () => {
            this.pushHandlers.get(event)?.delete(handler);
        };
    }
}

// React Context
const ApiClientContext = createContext<ApiClient | null>(null);

export const ApiClientProvider = ApiClientContext.Provider;

export function useApiClient(): ApiClient {
    const client = useContext(ApiClientContext);
    if (!client) {
        throw new Error('useApiClient must be used within an ApiClientProvider');
    }
    return client;
}

// Connection hook
export function useConnection(): { isConnected: boolean } {
    const client = useApiClient();
    const [isConnected, setIsConnected] = useState(client.isConnected());

    useEffect(() => {
        return client.onConnectionChange(setIsConnected);
    }, [client]);

    return { isConnected };
}

// Query hook options
export interface UseQueryOptions<TReq> {
    params: TReq;
    enabled?: boolean;
    refetchInterval?: number;
}

// Query hook result
export interface UseQueryResult<TRes> {
    data: TRes | null;
    error: Error | null;
    isLoading: boolean;
    refetch: () => void;
    mutate: (data: TRes | null) => void;
}

// Mutation hook options
export interface UseMutationOptions {
    onProgress?: (current: number, total: number, message: string) => void;
}

// Mutation hook result
export interface UseMutationResult<TReq, TRes> {
    mutate: (params: TReq) => Promise<TRes>;
    data: TRes | null;
    error: Error | null;
    isLoading: boolean;
    reset: () => void;
}

// Push event hook result
export interface UsePushResult<T> {
    lastEvent: T | null;
    events: T[];
    clear: () => void;
}
