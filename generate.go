package aprot

import (
	"fmt"
	"io"
	"reflect"
	"sort"
	"strings"
	"unicode"
)

// PushEventInfo describes a push event for code generation.
type PushEventInfo struct {
	Name     string
	DataType reflect.Type
}

// Generator generates TypeScript client code from a registry.
type Generator struct {
	registry   *Registry
	pushEvents []PushEventInfo
	types      map[reflect.Type]string
}

// NewGenerator creates a new TypeScript generator.
func NewGenerator(registry *Registry) *Generator {
	return &Generator{
		registry:   registry,
		pushEvents: []PushEventInfo{},
		types:      make(map[reflect.Type]string),
	}
}

// RegisterPushEvent registers a push event type for generation.
func (g *Generator) RegisterPushEvent(name string, dataType any) {
	t := reflect.TypeOf(dataType)
	if t.Kind() == reflect.Ptr {
		t = t.Elem()
	}
	g.pushEvents = append(g.pushEvents, PushEventInfo{
		Name:     name,
		DataType: t,
	})
}

// Generate writes the TypeScript client code to the writer.
func (g *Generator) Generate(w io.Writer) error {
	// Collect all types
	for _, info := range g.registry.Handlers() {
		g.collectType(info.RequestType)
		g.collectType(info.ResponseType)
	}
	for _, event := range g.pushEvents {
		g.collectType(event.DataType)
	}

	// Write header
	fmt.Fprintln(w, "// Code generated by aprot. DO NOT EDIT.")
	fmt.Fprintln(w, "")

	// Write interfaces
	if err := g.writeInterfaces(w); err != nil {
		return err
	}

	// Write client class
	if err := g.writeClient(w); err != nil {
		return err
	}

	return nil
}

func (g *Generator) collectType(t reflect.Type) {
	if t == nil {
		return
	}
	if _, ok := g.types[t]; ok {
		return
	}
	g.types[t] = t.Name()

	// Recursively collect field types
	for i := 0; i < t.NumField(); i++ {
		field := t.Field(i)
		ft := field.Type
		if ft.Kind() == reflect.Ptr {
			ft = ft.Elem()
		}
		if ft.Kind() == reflect.Struct && ft.PkgPath() != "" {
			g.collectType(ft)
		}
		if ft.Kind() == reflect.Slice && ft.Elem().Kind() == reflect.Struct {
			g.collectType(ft.Elem())
		}
	}
}

func (g *Generator) writeInterfaces(w io.Writer) error {
	// Sort types by name for deterministic output
	types := make([]reflect.Type, 0, len(g.types))
	for t := range g.types {
		types = append(types, t)
	}
	sort.Slice(types, func(i, j int) bool {
		return types[i].Name() < types[j].Name()
	})

	for _, t := range types {
		fmt.Fprintf(w, "export interface %s {\n", t.Name())
		for i := 0; i < t.NumField(); i++ {
			field := t.Field(i)
			if !field.IsExported() {
				continue
			}
			name := g.getJSONName(field)
			tsType := g.goTypeToTS(field.Type)
			optional := g.isOptional(field)
			if optional {
				fmt.Fprintf(w, "    %s?: %s;\n", name, tsType)
			} else {
				fmt.Fprintf(w, "    %s: %s;\n", name, tsType)
			}
		}
		fmt.Fprintln(w, "}")
		fmt.Fprintln(w, "")
	}
	return nil
}

func (g *Generator) writeClient(w io.Writer) error {
	// Write request options interface
	fmt.Fprintln(w, "export interface RequestOptions {")
	fmt.Fprintln(w, "    signal?: AbortSignal;")
	fmt.Fprintln(w, "    onProgress?: (current: number, total: number, message: string) => void;")
	fmt.Fprintln(w, "}")
	fmt.Fprintln(w, "")

	// Write push handler type
	fmt.Fprintln(w, "export type PushHandler<T> = (data: T) => void;")
	fmt.Fprintln(w, "")

	// Write client class
	fmt.Fprintln(w, "export class ApiClient {")
	fmt.Fprintln(w, "    private ws: WebSocket | null = null;")
	fmt.Fprintln(w, "    private url: string;")
	fmt.Fprintln(w, "    private requestId = 0;")
	fmt.Fprintln(w, "    private pending = new Map<string, {")
	fmt.Fprintln(w, "        resolve: (value: any) => void;")
	fmt.Fprintln(w, "        reject: (error: Error) => void;")
	fmt.Fprintln(w, "        onProgress?: (current: number, total: number, message: string) => void;")
	fmt.Fprintln(w, "    }>();")
	fmt.Fprintln(w, "    private pushHandlers = new Map<string, Set<(data: any) => void>>();")
	fmt.Fprintln(w, "")
	fmt.Fprintln(w, "    constructor(url: string) {")
	fmt.Fprintln(w, "        this.url = url;")
	fmt.Fprintln(w, "    }")
	fmt.Fprintln(w, "")
	fmt.Fprintln(w, "    connect(): Promise<void> {")
	fmt.Fprintln(w, "        return new Promise((resolve, reject) => {")
	fmt.Fprintln(w, "            this.ws = new WebSocket(this.url);")
	fmt.Fprintln(w, "            this.ws.onopen = () => resolve();")
	fmt.Fprintln(w, "            this.ws.onerror = (e) => reject(e);")
	fmt.Fprintln(w, "            this.ws.onmessage = (e) => this.handleMessage(e.data);")
	fmt.Fprintln(w, "            this.ws.onclose = () => {")
	fmt.Fprintln(w, "                for (const [, p] of this.pending) {")
	fmt.Fprintln(w, "                    p.reject(new Error('Connection closed'));")
	fmt.Fprintln(w, "                }")
	fmt.Fprintln(w, "                this.pending.clear();")
	fmt.Fprintln(w, "            };")
	fmt.Fprintln(w, "        });")
	fmt.Fprintln(w, "    }")
	fmt.Fprintln(w, "")
	fmt.Fprintln(w, "    disconnect(): void {")
	fmt.Fprintln(w, "        this.ws?.close();")
	fmt.Fprintln(w, "        this.ws = null;")
	fmt.Fprintln(w, "    }")
	fmt.Fprintln(w, "")
	fmt.Fprintln(w, "    private handleMessage(data: string): void {")
	fmt.Fprintln(w, "        const msg = JSON.parse(data);")
	fmt.Fprintln(w, "        switch (msg.type) {")
	fmt.Fprintln(w, "            case 'response': {")
	fmt.Fprintln(w, "                const p = this.pending.get(msg.id);")
	fmt.Fprintln(w, "                if (p) {")
	fmt.Fprintln(w, "                    this.pending.delete(msg.id);")
	fmt.Fprintln(w, "                    p.resolve(msg.result);")
	fmt.Fprintln(w, "                }")
	fmt.Fprintln(w, "                break;")
	fmt.Fprintln(w, "            }")
	fmt.Fprintln(w, "            case 'error': {")
	fmt.Fprintln(w, "                const p = this.pending.get(msg.id);")
	fmt.Fprintln(w, "                if (p) {")
	fmt.Fprintln(w, "                    this.pending.delete(msg.id);")
	fmt.Fprintln(w, "                    p.reject(new Error(`[${msg.code}] ${msg.message}`));")
	fmt.Fprintln(w, "                }")
	fmt.Fprintln(w, "                break;")
	fmt.Fprintln(w, "            }")
	fmt.Fprintln(w, "            case 'progress': {")
	fmt.Fprintln(w, "                const p = this.pending.get(msg.id);")
	fmt.Fprintln(w, "                if (p?.onProgress) {")
	fmt.Fprintln(w, "                    p.onProgress(msg.current, msg.total, msg.message);")
	fmt.Fprintln(w, "                }")
	fmt.Fprintln(w, "                break;")
	fmt.Fprintln(w, "            }")
	fmt.Fprintln(w, "            case 'push': {")
	fmt.Fprintln(w, "                const handlers = this.pushHandlers.get(msg.event);")
	fmt.Fprintln(w, "                if (handlers) {")
	fmt.Fprintln(w, "                    for (const handler of handlers) {")
	fmt.Fprintln(w, "                        handler(msg.data);")
	fmt.Fprintln(w, "                    }")
	fmt.Fprintln(w, "                }")
	fmt.Fprintln(w, "                break;")
	fmt.Fprintln(w, "            }")
	fmt.Fprintln(w, "        }")
	fmt.Fprintln(w, "    }")
	fmt.Fprintln(w, "")
	fmt.Fprintln(w, "    private request<T>(method: string, params: any, options?: RequestOptions): Promise<T> {")
	fmt.Fprintln(w, "        return new Promise((resolve, reject) => {")
	fmt.Fprintln(w, "            if (!this.ws || this.ws.readyState !== WebSocket.OPEN) {")
	fmt.Fprintln(w, "                reject(new Error('Not connected'));")
	fmt.Fprintln(w, "                return;")
	fmt.Fprintln(w, "            }")
	fmt.Fprintln(w, "            const id = String(++this.requestId);")
	fmt.Fprintln(w, "            this.pending.set(id, { resolve, reject, onProgress: options?.onProgress });")
	fmt.Fprintln(w, "            if (options?.signal) {")
	fmt.Fprintln(w, "                options.signal.addEventListener('abort', () => {")
	fmt.Fprintln(w, "                    this.ws?.send(JSON.stringify({ type: 'cancel', id }));")
	fmt.Fprintln(w, "                    this.pending.delete(id);")
	fmt.Fprintln(w, "                    reject(new Error('Request aborted'));")
	fmt.Fprintln(w, "                });")
	fmt.Fprintln(w, "            }")
	fmt.Fprintln(w, "            this.ws.send(JSON.stringify({ type: 'request', id, method, params }));")
	fmt.Fprintln(w, "        });")
	fmt.Fprintln(w, "    }")
	fmt.Fprintln(w, "")

	// Write method wrappers
	handlers := g.registry.Handlers()
	names := make([]string, 0, len(handlers))
	for name := range handlers {
		names = append(names, name)
	}
	sort.Strings(names)

	for _, name := range names {
		info := handlers[name]
		methodName := g.toLowerCamel(name)
		reqType := info.RequestType.Name()
		respType := info.ResponseType.Name()
		fmt.Fprintf(w, "    %s(req: %s, options?: RequestOptions): Promise<%s> {\n", methodName, reqType, respType)
		fmt.Fprintf(w, "        return this.request<%s>('%s', req, options);\n", respType, name)
		fmt.Fprintln(w, "    }")
		fmt.Fprintln(w, "")
	}

	// Write push event handlers
	for _, event := range g.pushEvents {
		handlerName := "on" + event.Name
		dataType := event.DataType.Name()
		fmt.Fprintf(w, "    %s(handler: PushHandler<%s>): () => void {\n", handlerName, dataType)
		fmt.Fprintf(w, "        if (!this.pushHandlers.has('%s')) {\n", event.Name)
		fmt.Fprintf(w, "            this.pushHandlers.set('%s', new Set());\n", event.Name)
		fmt.Fprintln(w, "        }")
		fmt.Fprintf(w, "        this.pushHandlers.get('%s')!.add(handler);\n", event.Name)
		fmt.Fprintln(w, "        return () => {")
		fmt.Fprintf(w, "            this.pushHandlers.get('%s')?.delete(handler);\n", event.Name)
		fmt.Fprintln(w, "        };")
		fmt.Fprintln(w, "    }")
		fmt.Fprintln(w, "")
	}

	fmt.Fprintln(w, "}")

	return nil
}

func (g *Generator) getJSONName(field reflect.StructField) string {
	tag := field.Tag.Get("json")
	if tag == "" {
		return g.toLowerCamel(field.Name)
	}
	parts := strings.Split(tag, ",")
	if parts[0] == "" || parts[0] == "-" {
		return g.toLowerCamel(field.Name)
	}
	return parts[0]
}

func (g *Generator) isOptional(field reflect.StructField) bool {
	tag := field.Tag.Get("json")
	if strings.Contains(tag, "omitempty") {
		return true
	}
	// Pointers are optional
	if field.Type.Kind() == reflect.Ptr {
		return true
	}
	return false
}

func (g *Generator) goTypeToTS(t reflect.Type) string {
	switch t.Kind() {
	case reflect.String:
		return "string"
	case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64,
		reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64,
		reflect.Float32, reflect.Float64:
		return "number"
	case reflect.Bool:
		return "boolean"
	case reflect.Slice:
		elemType := g.goTypeToTS(t.Elem())
		return elemType + "[]"
	case reflect.Map:
		keyType := g.goTypeToTS(t.Key())
		valType := g.goTypeToTS(t.Elem())
		return fmt.Sprintf("Record<%s, %s>", keyType, valType)
	case reflect.Ptr:
		return g.goTypeToTS(t.Elem())
	case reflect.Struct:
		if t.PkgPath() == "" {
			// Anonymous struct or time.Time
			if t.String() == "time.Time" {
				return "string" // ISO date string
			}
			return "any"
		}
		return t.Name()
	case reflect.Interface:
		return "any"
	default:
		return "any"
	}
}

func (g *Generator) toLowerCamel(s string) string {
	if s == "" {
		return s
	}
	runes := []rune(s)
	runes[0] = unicode.ToLower(runes[0])
	return string(runes)
}
