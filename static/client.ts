// Code generated by aprot. DO NOT EDIT.

export interface CreateUserRequest {
    name: string;
    email: string;
}

export interface CreateUserResponse {
    id: string;
    name: string;
    email: string;
}

export interface GetUserRequest {
    id: string;
}

export interface GetUserResponse {
    id: string;
    name: string;
    email: string;
}

export interface ListUsersRequest {
}

export interface ListUsersResponse {
    users: User[];
}

export interface ProcessBatchRequest {
    items: string[];
    delay: number;
}

export interface ProcessBatchResponse {
    processed: number;
    results: string[];
}

export interface SystemNotification {
    message: string;
    level: string;
}

export interface User {
    id: string;
    name: string;
    email: string;
}

export interface UserCreatedEvent {
    id: string;
    name: string;
    email: string;
}

export interface UserUpdatedEvent {
    id: string;
    name: string;
    email: string;
}

export interface RequestOptions {
    signal?: AbortSignal;
    onProgress?: (current: number, total: number, message: string) => void;
}

export type PushHandler<T> = (data: T) => void;

export class ApiClient {
    private ws: WebSocket | null = null;
    private url: string;
    private requestId = 0;
    private pending = new Map<string, {
        resolve: (value: any) => void;
        reject: (error: Error) => void;
        onProgress?: (current: number, total: number, message: string) => void;
    }>();
    private pushHandlers = new Map<string, Set<(data: any) => void>>();

    constructor(url: string) {
        this.url = url;
    }

    connect(): Promise<void> {
        return new Promise((resolve, reject) => {
            this.ws = new WebSocket(this.url);
            this.ws.onopen = () => resolve();
            this.ws.onerror = (e) => reject(e);
            this.ws.onmessage = (e) => this.handleMessage(e.data);
            this.ws.onclose = () => {
                for (const [, p] of this.pending) {
                    p.reject(new Error('Connection closed'));
                }
                this.pending.clear();
            };
        });
    }

    disconnect(): void {
        this.ws?.close();
        this.ws = null;
    }

    private handleMessage(data: string): void {
        const msg = JSON.parse(data);
        switch (msg.type) {
            case 'response': {
                const p = this.pending.get(msg.id);
                if (p) {
                    this.pending.delete(msg.id);
                    p.resolve(msg.result);
                }
                break;
            }
            case 'error': {
                const p = this.pending.get(msg.id);
                if (p) {
                    this.pending.delete(msg.id);
                    p.reject(new Error(`[${msg.code}] ${msg.message}`));
                }
                break;
            }
            case 'progress': {
                const p = this.pending.get(msg.id);
                if (p?.onProgress) {
                    p.onProgress(msg.current, msg.total, msg.message);
                }
                break;
            }
            case 'push': {
                const handlers = this.pushHandlers.get(msg.event);
                if (handlers) {
                    for (const handler of handlers) {
                        handler(msg.data);
                    }
                }
                break;
            }
        }
    }

    private request<T>(method: string, params: any, options?: RequestOptions): Promise<T> {
        return new Promise((resolve, reject) => {
            if (!this.ws || this.ws.readyState !== WebSocket.OPEN) {
                reject(new Error('Not connected'));
                return;
            }
            const id = String(++this.requestId);
            this.pending.set(id, { resolve, reject, onProgress: options?.onProgress });
            if (options?.signal) {
                options.signal.addEventListener('abort', () => {
                    this.ws?.send(JSON.stringify({ type: 'cancel', id }));
                    this.pending.delete(id);
                    reject(new Error('Request aborted'));
                });
            }
            this.ws.send(JSON.stringify({ type: 'request', id, method, params }));
        });
    }

    createUser(req: CreateUserRequest, options?: RequestOptions): Promise<CreateUserResponse> {
        return this.request<CreateUserResponse>('CreateUser', req, options);
    }

    getUser(req: GetUserRequest, options?: RequestOptions): Promise<GetUserResponse> {
        return this.request<GetUserResponse>('GetUser', req, options);
    }

    listUsers(req: ListUsersRequest, options?: RequestOptions): Promise<ListUsersResponse> {
        return this.request<ListUsersResponse>('ListUsers', req, options);
    }

    processBatch(req: ProcessBatchRequest, options?: RequestOptions): Promise<ProcessBatchResponse> {
        return this.request<ProcessBatchResponse>('ProcessBatch', req, options);
    }

    sendNotification(req: SystemNotification, options?: RequestOptions): Promise<SystemNotification> {
        return this.request<SystemNotification>('SendNotification', req, options);
    }

    onUserCreated(handler: PushHandler<UserCreatedEvent>): () => void {
        if (!this.pushHandlers.has('UserCreated')) {
            this.pushHandlers.set('UserCreated', new Set());
        }
        this.pushHandlers.get('UserCreated')!.add(handler);
        return () => {
            this.pushHandlers.get('UserCreated')?.delete(handler);
        };
    }

    onUserUpdated(handler: PushHandler<UserUpdatedEvent>): () => void {
        if (!this.pushHandlers.has('UserUpdated')) {
            this.pushHandlers.set('UserUpdated', new Set());
        }
        this.pushHandlers.get('UserUpdated')!.add(handler);
        return () => {
            this.pushHandlers.get('UserUpdated')?.delete(handler);
        };
    }

    onSystemNotification(handler: PushHandler<SystemNotification>): () => void {
        if (!this.pushHandlers.has('SystemNotification')) {
            this.pushHandlers.set('SystemNotification', new Set());
        }
        this.pushHandlers.get('SystemNotification')!.add(handler);
        return () => {
            this.pushHandlers.get('SystemNotification')?.delete(handler);
        };
    }

}
